// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.12.4
// source: joblet.proto

package gen

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	JobService_RunJob_FullMethodName              = "/joblet.JobService/RunJob"
	JobService_GetJobStatus_FullMethodName        = "/joblet.JobService/GetJobStatus"
	JobService_StopJob_FullMethodName             = "/joblet.JobService/StopJob"
	JobService_CancelJob_FullMethodName           = "/joblet.JobService/CancelJob"
	JobService_DeleteJob_FullMethodName           = "/joblet.JobService/DeleteJob"
	JobService_DeleteAllJobs_FullMethodName       = "/joblet.JobService/DeleteAllJobs"
	JobService_GetJobLogs_FullMethodName          = "/joblet.JobService/GetJobLogs"
	JobService_ListJobs_FullMethodName            = "/joblet.JobService/ListJobs"
	JobService_StreamJobMetrics_FullMethodName    = "/joblet.JobService/StreamJobMetrics"
	JobService_GetJobMetrics_FullMethodName       = "/joblet.JobService/GetJobMetrics"
	JobService_StreamJobTelematics_FullMethodName = "/joblet.JobService/StreamJobTelematics"
	JobService_GetJobTelematics_FullMethodName    = "/joblet.JobService/GetJobTelematics"
)

// JobServiceClient is the client API for JobService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Main service for running jobs
type JobServiceClient interface {
	// Job operations
	RunJob(ctx context.Context, in *RunJobRequest, opts ...grpc.CallOption) (*RunJobResponse, error)
	GetJobStatus(ctx context.Context, in *GetJobStatusRequest, opts ...grpc.CallOption) (*GetJobStatusResponse, error)
	StopJob(ctx context.Context, in *StopJobRequest, opts ...grpc.CallOption) (*StopJobResponse, error)
	CancelJob(ctx context.Context, in *CancelJobRequest, opts ...grpc.CallOption) (*CancelJobResponse, error)
	DeleteJob(ctx context.Context, in *DeleteJobRequest, opts ...grpc.CallOption) (*DeleteJobResponse, error)
	DeleteAllJobs(ctx context.Context, in *DeleteAllJobsRequest, opts ...grpc.CallOption) (*DeleteAllJobsResponse, error)
	GetJobLogs(ctx context.Context, in *GetJobLogsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DataChunk], error)
	ListJobs(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*Jobs, error)
	// Job Metrics (resource usage from cgroups - sampled every 5s)
	// Stream live metrics for a running job
	StreamJobMetrics(ctx context.Context, in *StreamJobMetricsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[JobMetricsEvent], error)
	// Get historical metrics for a completed job
	GetJobMetrics(ctx context.Context, in *GetJobMetricsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[JobMetricsEvent], error)
	// Job Telematics (eBPF security events - event-driven)
	// Stream live telematics events for a running job
	StreamJobTelematics(ctx context.Context, in *StreamJobTelematicsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[TelematicsEvent], error)
	// Get historical telematics events for a completed job
	GetJobTelematics(ctx context.Context, in *GetJobTelematicsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[TelematicsEvent], error)
}

type jobServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewJobServiceClient(cc grpc.ClientConnInterface) JobServiceClient {
	return &jobServiceClient{cc}
}

func (c *jobServiceClient) RunJob(ctx context.Context, in *RunJobRequest, opts ...grpc.CallOption) (*RunJobResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RunJobResponse)
	err := c.cc.Invoke(ctx, JobService_RunJob_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobServiceClient) GetJobStatus(ctx context.Context, in *GetJobStatusRequest, opts ...grpc.CallOption) (*GetJobStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetJobStatusResponse)
	err := c.cc.Invoke(ctx, JobService_GetJobStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobServiceClient) StopJob(ctx context.Context, in *StopJobRequest, opts ...grpc.CallOption) (*StopJobResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StopJobResponse)
	err := c.cc.Invoke(ctx, JobService_StopJob_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobServiceClient) CancelJob(ctx context.Context, in *CancelJobRequest, opts ...grpc.CallOption) (*CancelJobResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CancelJobResponse)
	err := c.cc.Invoke(ctx, JobService_CancelJob_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobServiceClient) DeleteJob(ctx context.Context, in *DeleteJobRequest, opts ...grpc.CallOption) (*DeleteJobResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteJobResponse)
	err := c.cc.Invoke(ctx, JobService_DeleteJob_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobServiceClient) DeleteAllJobs(ctx context.Context, in *DeleteAllJobsRequest, opts ...grpc.CallOption) (*DeleteAllJobsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteAllJobsResponse)
	err := c.cc.Invoke(ctx, JobService_DeleteAllJobs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobServiceClient) GetJobLogs(ctx context.Context, in *GetJobLogsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DataChunk], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &JobService_ServiceDesc.Streams[0], JobService_GetJobLogs_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[GetJobLogsRequest, DataChunk]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type JobService_GetJobLogsClient = grpc.ServerStreamingClient[DataChunk]

func (c *jobServiceClient) ListJobs(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*Jobs, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Jobs)
	err := c.cc.Invoke(ctx, JobService_ListJobs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobServiceClient) StreamJobMetrics(ctx context.Context, in *StreamJobMetricsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[JobMetricsEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &JobService_ServiceDesc.Streams[1], JobService_StreamJobMetrics_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamJobMetricsRequest, JobMetricsEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type JobService_StreamJobMetricsClient = grpc.ServerStreamingClient[JobMetricsEvent]

func (c *jobServiceClient) GetJobMetrics(ctx context.Context, in *GetJobMetricsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[JobMetricsEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &JobService_ServiceDesc.Streams[2], JobService_GetJobMetrics_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[GetJobMetricsRequest, JobMetricsEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type JobService_GetJobMetricsClient = grpc.ServerStreamingClient[JobMetricsEvent]

func (c *jobServiceClient) StreamJobTelematics(ctx context.Context, in *StreamJobTelematicsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[TelematicsEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &JobService_ServiceDesc.Streams[3], JobService_StreamJobTelematics_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamJobTelematicsRequest, TelematicsEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type JobService_StreamJobTelematicsClient = grpc.ServerStreamingClient[TelematicsEvent]

func (c *jobServiceClient) GetJobTelematics(ctx context.Context, in *GetJobTelematicsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[TelematicsEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &JobService_ServiceDesc.Streams[4], JobService_GetJobTelematics_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[GetJobTelematicsRequest, TelematicsEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type JobService_GetJobTelematicsClient = grpc.ServerStreamingClient[TelematicsEvent]

// JobServiceServer is the server API for JobService service.
// All implementations must embed UnimplementedJobServiceServer
// for forward compatibility.
//
// Main service for running jobs
type JobServiceServer interface {
	// Job operations
	RunJob(context.Context, *RunJobRequest) (*RunJobResponse, error)
	GetJobStatus(context.Context, *GetJobStatusRequest) (*GetJobStatusResponse, error)
	StopJob(context.Context, *StopJobRequest) (*StopJobResponse, error)
	CancelJob(context.Context, *CancelJobRequest) (*CancelJobResponse, error)
	DeleteJob(context.Context, *DeleteJobRequest) (*DeleteJobResponse, error)
	DeleteAllJobs(context.Context, *DeleteAllJobsRequest) (*DeleteAllJobsResponse, error)
	GetJobLogs(*GetJobLogsRequest, grpc.ServerStreamingServer[DataChunk]) error
	ListJobs(context.Context, *EmptyRequest) (*Jobs, error)
	// Job Metrics (resource usage from cgroups - sampled every 5s)
	// Stream live metrics for a running job
	StreamJobMetrics(*StreamJobMetricsRequest, grpc.ServerStreamingServer[JobMetricsEvent]) error
	// Get historical metrics for a completed job
	GetJobMetrics(*GetJobMetricsRequest, grpc.ServerStreamingServer[JobMetricsEvent]) error
	// Job Telematics (eBPF security events - event-driven)
	// Stream live telematics events for a running job
	StreamJobTelematics(*StreamJobTelematicsRequest, grpc.ServerStreamingServer[TelematicsEvent]) error
	// Get historical telematics events for a completed job
	GetJobTelematics(*GetJobTelematicsRequest, grpc.ServerStreamingServer[TelematicsEvent]) error
	mustEmbedUnimplementedJobServiceServer()
}

// UnimplementedJobServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedJobServiceServer struct{}

func (UnimplementedJobServiceServer) RunJob(context.Context, *RunJobRequest) (*RunJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunJob not implemented")
}
func (UnimplementedJobServiceServer) GetJobStatus(context.Context, *GetJobStatusRequest) (*GetJobStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetJobStatus not implemented")
}
func (UnimplementedJobServiceServer) StopJob(context.Context, *StopJobRequest) (*StopJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopJob not implemented")
}
func (UnimplementedJobServiceServer) CancelJob(context.Context, *CancelJobRequest) (*CancelJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelJob not implemented")
}
func (UnimplementedJobServiceServer) DeleteJob(context.Context, *DeleteJobRequest) (*DeleteJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteJob not implemented")
}
func (UnimplementedJobServiceServer) DeleteAllJobs(context.Context, *DeleteAllJobsRequest) (*DeleteAllJobsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAllJobs not implemented")
}
func (UnimplementedJobServiceServer) GetJobLogs(*GetJobLogsRequest, grpc.ServerStreamingServer[DataChunk]) error {
	return status.Errorf(codes.Unimplemented, "method GetJobLogs not implemented")
}
func (UnimplementedJobServiceServer) ListJobs(context.Context, *EmptyRequest) (*Jobs, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListJobs not implemented")
}
func (UnimplementedJobServiceServer) StreamJobMetrics(*StreamJobMetricsRequest, grpc.ServerStreamingServer[JobMetricsEvent]) error {
	return status.Errorf(codes.Unimplemented, "method StreamJobMetrics not implemented")
}
func (UnimplementedJobServiceServer) GetJobMetrics(*GetJobMetricsRequest, grpc.ServerStreamingServer[JobMetricsEvent]) error {
	return status.Errorf(codes.Unimplemented, "method GetJobMetrics not implemented")
}
func (UnimplementedJobServiceServer) StreamJobTelematics(*StreamJobTelematicsRequest, grpc.ServerStreamingServer[TelematicsEvent]) error {
	return status.Errorf(codes.Unimplemented, "method StreamJobTelematics not implemented")
}
func (UnimplementedJobServiceServer) GetJobTelematics(*GetJobTelematicsRequest, grpc.ServerStreamingServer[TelematicsEvent]) error {
	return status.Errorf(codes.Unimplemented, "method GetJobTelematics not implemented")
}
func (UnimplementedJobServiceServer) mustEmbedUnimplementedJobServiceServer() {}
func (UnimplementedJobServiceServer) testEmbeddedByValue()                    {}

// UnsafeJobServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to JobServiceServer will
// result in compilation errors.
type UnsafeJobServiceServer interface {
	mustEmbedUnimplementedJobServiceServer()
}

func RegisterJobServiceServer(s grpc.ServiceRegistrar, srv JobServiceServer) {
	// If the following call pancis, it indicates UnimplementedJobServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&JobService_ServiceDesc, srv)
}

func _JobService_RunJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobServiceServer).RunJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobService_RunJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobServiceServer).RunJob(ctx, req.(*RunJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobService_GetJobStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetJobStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobServiceServer).GetJobStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobService_GetJobStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobServiceServer).GetJobStatus(ctx, req.(*GetJobStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobService_StopJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobServiceServer).StopJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobService_StopJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobServiceServer).StopJob(ctx, req.(*StopJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobService_CancelJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobServiceServer).CancelJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobService_CancelJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobServiceServer).CancelJob(ctx, req.(*CancelJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobService_DeleteJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobServiceServer).DeleteJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobService_DeleteJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobServiceServer).DeleteJob(ctx, req.(*DeleteJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobService_DeleteAllJobs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAllJobsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobServiceServer).DeleteAllJobs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobService_DeleteAllJobs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobServiceServer).DeleteAllJobs(ctx, req.(*DeleteAllJobsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobService_GetJobLogs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetJobLogsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(JobServiceServer).GetJobLogs(m, &grpc.GenericServerStream[GetJobLogsRequest, DataChunk]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type JobService_GetJobLogsServer = grpc.ServerStreamingServer[DataChunk]

func _JobService_ListJobs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobServiceServer).ListJobs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobService_ListJobs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobServiceServer).ListJobs(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobService_StreamJobMetrics_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamJobMetricsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(JobServiceServer).StreamJobMetrics(m, &grpc.GenericServerStream[StreamJobMetricsRequest, JobMetricsEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type JobService_StreamJobMetricsServer = grpc.ServerStreamingServer[JobMetricsEvent]

func _JobService_GetJobMetrics_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetJobMetricsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(JobServiceServer).GetJobMetrics(m, &grpc.GenericServerStream[GetJobMetricsRequest, JobMetricsEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type JobService_GetJobMetricsServer = grpc.ServerStreamingServer[JobMetricsEvent]

func _JobService_StreamJobTelematics_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamJobTelematicsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(JobServiceServer).StreamJobTelematics(m, &grpc.GenericServerStream[StreamJobTelematicsRequest, TelematicsEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type JobService_StreamJobTelematicsServer = grpc.ServerStreamingServer[TelematicsEvent]

func _JobService_GetJobTelematics_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetJobTelematicsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(JobServiceServer).GetJobTelematics(m, &grpc.GenericServerStream[GetJobTelematicsRequest, TelematicsEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type JobService_GetJobTelematicsServer = grpc.ServerStreamingServer[TelematicsEvent]

// JobService_ServiceDesc is the grpc.ServiceDesc for JobService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var JobService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "joblet.JobService",
	HandlerType: (*JobServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RunJob",
			Handler:    _JobService_RunJob_Handler,
		},
		{
			MethodName: "GetJobStatus",
			Handler:    _JobService_GetJobStatus_Handler,
		},
		{
			MethodName: "StopJob",
			Handler:    _JobService_StopJob_Handler,
		},
		{
			MethodName: "CancelJob",
			Handler:    _JobService_CancelJob_Handler,
		},
		{
			MethodName: "DeleteJob",
			Handler:    _JobService_DeleteJob_Handler,
		},
		{
			MethodName: "DeleteAllJobs",
			Handler:    _JobService_DeleteAllJobs_Handler,
		},
		{
			MethodName: "ListJobs",
			Handler:    _JobService_ListJobs_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetJobLogs",
			Handler:       _JobService_GetJobLogs_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamJobMetrics",
			Handler:       _JobService_StreamJobMetrics_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetJobMetrics",
			Handler:       _JobService_GetJobMetrics_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamJobTelematics",
			Handler:       _JobService_StreamJobTelematics_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetJobTelematics",
			Handler:       _JobService_GetJobTelematics_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "joblet.proto",
}

const (
	NetworkService_CreateNetwork_FullMethodName = "/joblet.NetworkService/CreateNetwork"
	NetworkService_ListNetworks_FullMethodName  = "/joblet.NetworkService/ListNetworks"
	NetworkService_RemoveNetwork_FullMethodName = "/joblet.NetworkService/RemoveNetwork"
)

// NetworkServiceClient is the client API for NetworkService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Network service
type NetworkServiceClient interface {
	CreateNetwork(ctx context.Context, in *CreateNetworkRequest, opts ...grpc.CallOption) (*CreateNetworkResponse, error)
	ListNetworks(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*Networks, error)
	RemoveNetwork(ctx context.Context, in *RemoveNetworkRequest, opts ...grpc.CallOption) (*RemoveNetworkResponse, error)
}

type networkServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNetworkServiceClient(cc grpc.ClientConnInterface) NetworkServiceClient {
	return &networkServiceClient{cc}
}

func (c *networkServiceClient) CreateNetwork(ctx context.Context, in *CreateNetworkRequest, opts ...grpc.CallOption) (*CreateNetworkResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateNetworkResponse)
	err := c.cc.Invoke(ctx, NetworkService_CreateNetwork_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkServiceClient) ListNetworks(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*Networks, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Networks)
	err := c.cc.Invoke(ctx, NetworkService_ListNetworks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkServiceClient) RemoveNetwork(ctx context.Context, in *RemoveNetworkRequest, opts ...grpc.CallOption) (*RemoveNetworkResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RemoveNetworkResponse)
	err := c.cc.Invoke(ctx, NetworkService_RemoveNetwork_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NetworkServiceServer is the server API for NetworkService service.
// All implementations must embed UnimplementedNetworkServiceServer
// for forward compatibility.
//
// Network service
type NetworkServiceServer interface {
	CreateNetwork(context.Context, *CreateNetworkRequest) (*CreateNetworkResponse, error)
	ListNetworks(context.Context, *EmptyRequest) (*Networks, error)
	RemoveNetwork(context.Context, *RemoveNetworkRequest) (*RemoveNetworkResponse, error)
	mustEmbedUnimplementedNetworkServiceServer()
}

// UnimplementedNetworkServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedNetworkServiceServer struct{}

func (UnimplementedNetworkServiceServer) CreateNetwork(context.Context, *CreateNetworkRequest) (*CreateNetworkResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateNetwork not implemented")
}
func (UnimplementedNetworkServiceServer) ListNetworks(context.Context, *EmptyRequest) (*Networks, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNetworks not implemented")
}
func (UnimplementedNetworkServiceServer) RemoveNetwork(context.Context, *RemoveNetworkRequest) (*RemoveNetworkResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveNetwork not implemented")
}
func (UnimplementedNetworkServiceServer) mustEmbedUnimplementedNetworkServiceServer() {}
func (UnimplementedNetworkServiceServer) testEmbeddedByValue()                        {}

// UnsafeNetworkServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NetworkServiceServer will
// result in compilation errors.
type UnsafeNetworkServiceServer interface {
	mustEmbedUnimplementedNetworkServiceServer()
}

func RegisterNetworkServiceServer(s grpc.ServiceRegistrar, srv NetworkServiceServer) {
	// If the following call pancis, it indicates UnimplementedNetworkServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&NetworkService_ServiceDesc, srv)
}

func _NetworkService_CreateNetwork_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateNetworkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkServiceServer).CreateNetwork(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkService_CreateNetwork_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkServiceServer).CreateNetwork(ctx, req.(*CreateNetworkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkService_ListNetworks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkServiceServer).ListNetworks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkService_ListNetworks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkServiceServer).ListNetworks(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkService_RemoveNetwork_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveNetworkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkServiceServer).RemoveNetwork(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkService_RemoveNetwork_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkServiceServer).RemoveNetwork(ctx, req.(*RemoveNetworkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NetworkService_ServiceDesc is the grpc.ServiceDesc for NetworkService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NetworkService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "joblet.NetworkService",
	HandlerType: (*NetworkServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateNetwork",
			Handler:    _NetworkService_CreateNetwork_Handler,
		},
		{
			MethodName: "ListNetworks",
			Handler:    _NetworkService_ListNetworks_Handler,
		},
		{
			MethodName: "RemoveNetwork",
			Handler:    _NetworkService_RemoveNetwork_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "joblet.proto",
}

const (
	VolumeService_CreateVolume_FullMethodName = "/joblet.VolumeService/CreateVolume"
	VolumeService_ListVolumes_FullMethodName  = "/joblet.VolumeService/ListVolumes"
	VolumeService_RemoveVolume_FullMethodName = "/joblet.VolumeService/RemoveVolume"
)

// VolumeServiceClient is the client API for VolumeService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Volume service
type VolumeServiceClient interface {
	CreateVolume(ctx context.Context, in *CreateVolumeRequest, opts ...grpc.CallOption) (*CreateVolumeResponse, error)
	ListVolumes(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*Volumes, error)
	RemoveVolume(ctx context.Context, in *RemoveVolumeRequest, opts ...grpc.CallOption) (*RemoveVolumeResponse, error)
}

type volumeServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewVolumeServiceClient(cc grpc.ClientConnInterface) VolumeServiceClient {
	return &volumeServiceClient{cc}
}

func (c *volumeServiceClient) CreateVolume(ctx context.Context, in *CreateVolumeRequest, opts ...grpc.CallOption) (*CreateVolumeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateVolumeResponse)
	err := c.cc.Invoke(ctx, VolumeService_CreateVolume_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumeServiceClient) ListVolumes(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*Volumes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Volumes)
	err := c.cc.Invoke(ctx, VolumeService_ListVolumes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumeServiceClient) RemoveVolume(ctx context.Context, in *RemoveVolumeRequest, opts ...grpc.CallOption) (*RemoveVolumeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RemoveVolumeResponse)
	err := c.cc.Invoke(ctx, VolumeService_RemoveVolume_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VolumeServiceServer is the server API for VolumeService service.
// All implementations must embed UnimplementedVolumeServiceServer
// for forward compatibility.
//
// Volume service
type VolumeServiceServer interface {
	CreateVolume(context.Context, *CreateVolumeRequest) (*CreateVolumeResponse, error)
	ListVolumes(context.Context, *EmptyRequest) (*Volumes, error)
	RemoveVolume(context.Context, *RemoveVolumeRequest) (*RemoveVolumeResponse, error)
	mustEmbedUnimplementedVolumeServiceServer()
}

// UnimplementedVolumeServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedVolumeServiceServer struct{}

func (UnimplementedVolumeServiceServer) CreateVolume(context.Context, *CreateVolumeRequest) (*CreateVolumeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateVolume not implemented")
}
func (UnimplementedVolumeServiceServer) ListVolumes(context.Context, *EmptyRequest) (*Volumes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListVolumes not implemented")
}
func (UnimplementedVolumeServiceServer) RemoveVolume(context.Context, *RemoveVolumeRequest) (*RemoveVolumeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveVolume not implemented")
}
func (UnimplementedVolumeServiceServer) mustEmbedUnimplementedVolumeServiceServer() {}
func (UnimplementedVolumeServiceServer) testEmbeddedByValue()                       {}

// UnsafeVolumeServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VolumeServiceServer will
// result in compilation errors.
type UnsafeVolumeServiceServer interface {
	mustEmbedUnimplementedVolumeServiceServer()
}

func RegisterVolumeServiceServer(s grpc.ServiceRegistrar, srv VolumeServiceServer) {
	// If the following call pancis, it indicates UnimplementedVolumeServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&VolumeService_ServiceDesc, srv)
}

func _VolumeService_CreateVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateVolumeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServiceServer).CreateVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VolumeService_CreateVolume_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServiceServer).CreateVolume(ctx, req.(*CreateVolumeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VolumeService_ListVolumes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServiceServer).ListVolumes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VolumeService_ListVolumes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServiceServer).ListVolumes(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VolumeService_RemoveVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveVolumeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServiceServer).RemoveVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VolumeService_RemoveVolume_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServiceServer).RemoveVolume(ctx, req.(*RemoveVolumeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// VolumeService_ServiceDesc is the grpc.ServiceDesc for VolumeService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VolumeService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "joblet.VolumeService",
	HandlerType: (*VolumeServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateVolume",
			Handler:    _VolumeService_CreateVolume_Handler,
		},
		{
			MethodName: "ListVolumes",
			Handler:    _VolumeService_ListVolumes_Handler,
		},
		{
			MethodName: "RemoveVolume",
			Handler:    _VolumeService_RemoveVolume_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "joblet.proto",
}

const (
	MonitoringService_GetSystemStatus_FullMethodName     = "/joblet.MonitoringService/GetSystemStatus"
	MonitoringService_StreamSystemMetrics_FullMethodName = "/joblet.MonitoringService/StreamSystemMetrics"
)

// MonitoringServiceClient is the client API for MonitoringService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Monitoring service
type MonitoringServiceClient interface {
	GetSystemStatus(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*SystemStatusResponse, error)
	StreamSystemMetrics(ctx context.Context, in *StreamMetricsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SystemMetricsResponse], error)
}

type monitoringServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMonitoringServiceClient(cc grpc.ClientConnInterface) MonitoringServiceClient {
	return &monitoringServiceClient{cc}
}

func (c *monitoringServiceClient) GetSystemStatus(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*SystemStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SystemStatusResponse)
	err := c.cc.Invoke(ctx, MonitoringService_GetSystemStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monitoringServiceClient) StreamSystemMetrics(ctx context.Context, in *StreamMetricsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SystemMetricsResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &MonitoringService_ServiceDesc.Streams[0], MonitoringService_StreamSystemMetrics_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamMetricsRequest, SystemMetricsResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MonitoringService_StreamSystemMetricsClient = grpc.ServerStreamingClient[SystemMetricsResponse]

// MonitoringServiceServer is the server API for MonitoringService service.
// All implementations must embed UnimplementedMonitoringServiceServer
// for forward compatibility.
//
// Monitoring service
type MonitoringServiceServer interface {
	GetSystemStatus(context.Context, *EmptyRequest) (*SystemStatusResponse, error)
	StreamSystemMetrics(*StreamMetricsRequest, grpc.ServerStreamingServer[SystemMetricsResponse]) error
	mustEmbedUnimplementedMonitoringServiceServer()
}

// UnimplementedMonitoringServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMonitoringServiceServer struct{}

func (UnimplementedMonitoringServiceServer) GetSystemStatus(context.Context, *EmptyRequest) (*SystemStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSystemStatus not implemented")
}
func (UnimplementedMonitoringServiceServer) StreamSystemMetrics(*StreamMetricsRequest, grpc.ServerStreamingServer[SystemMetricsResponse]) error {
	return status.Errorf(codes.Unimplemented, "method StreamSystemMetrics not implemented")
}
func (UnimplementedMonitoringServiceServer) mustEmbedUnimplementedMonitoringServiceServer() {}
func (UnimplementedMonitoringServiceServer) testEmbeddedByValue()                           {}

// UnsafeMonitoringServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MonitoringServiceServer will
// result in compilation errors.
type UnsafeMonitoringServiceServer interface {
	mustEmbedUnimplementedMonitoringServiceServer()
}

func RegisterMonitoringServiceServer(s grpc.ServiceRegistrar, srv MonitoringServiceServer) {
	// If the following call pancis, it indicates UnimplementedMonitoringServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MonitoringService_ServiceDesc, srv)
}

func _MonitoringService_GetSystemStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonitoringServiceServer).GetSystemStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MonitoringService_GetSystemStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonitoringServiceServer).GetSystemStatus(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MonitoringService_StreamSystemMetrics_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamMetricsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MonitoringServiceServer).StreamSystemMetrics(m, &grpc.GenericServerStream[StreamMetricsRequest, SystemMetricsResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MonitoringService_StreamSystemMetricsServer = grpc.ServerStreamingServer[SystemMetricsResponse]

// MonitoringService_ServiceDesc is the grpc.ServiceDesc for MonitoringService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MonitoringService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "joblet.MonitoringService",
	HandlerType: (*MonitoringServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetSystemStatus",
			Handler:    _MonitoringService_GetSystemStatus_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamSystemMetrics",
			Handler:       _MonitoringService_StreamSystemMetrics_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "joblet.proto",
}

const (
	RuntimeService_ListRuntimes_FullMethodName        = "/joblet.RuntimeService/ListRuntimes"
	RuntimeService_GetRuntimeInfo_FullMethodName      = "/joblet.RuntimeService/GetRuntimeInfo"
	RuntimeService_TestRuntime_FullMethodName         = "/joblet.RuntimeService/TestRuntime"
	RuntimeService_RemoveRuntime_FullMethodName       = "/joblet.RuntimeService/RemoveRuntime"
	RuntimeService_BuildRuntime_FullMethodName        = "/joblet.RuntimeService/BuildRuntime"
	RuntimeService_ValidateRuntimeYAML_FullMethodName = "/joblet.RuntimeService/ValidateRuntimeYAML"
)

// RuntimeServiceClient is the client API for RuntimeService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Runtime service for managing execution environments
type RuntimeServiceClient interface {
	ListRuntimes(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ListRuntimesResponse, error)
	GetRuntimeInfo(ctx context.Context, in *GetRuntimeInfoRequest, opts ...grpc.CallOption) (*GetRuntimeInfoResponse, error)
	TestRuntime(ctx context.Context, in *TestRuntimeRequest, opts ...grpc.CallOption) (*TestRuntimeResponse, error)
	RemoveRuntime(ctx context.Context, in *RemoveRuntimeRequest, opts ...grpc.CallOption) (*RemoveRuntimeResponse, error)
	// BuildRuntime builds a runtime from a YAML specification
	// The build process runs on the server and streams progress back to the client
	BuildRuntime(ctx context.Context, in *BuildRuntimeRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BuildRuntimeProgress], error)
	// ValidateRuntimeYAML validates a runtime YAML specification without building
	ValidateRuntimeYAML(ctx context.Context, in *ValidateRuntimeYAMLRequest, opts ...grpc.CallOption) (*ValidateRuntimeYAMLResponse, error)
}

type runtimeServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewRuntimeServiceClient(cc grpc.ClientConnInterface) RuntimeServiceClient {
	return &runtimeServiceClient{cc}
}

func (c *runtimeServiceClient) ListRuntimes(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*ListRuntimesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListRuntimesResponse)
	err := c.cc.Invoke(ctx, RuntimeService_ListRuntimes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) GetRuntimeInfo(ctx context.Context, in *GetRuntimeInfoRequest, opts ...grpc.CallOption) (*GetRuntimeInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRuntimeInfoResponse)
	err := c.cc.Invoke(ctx, RuntimeService_GetRuntimeInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) TestRuntime(ctx context.Context, in *TestRuntimeRequest, opts ...grpc.CallOption) (*TestRuntimeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TestRuntimeResponse)
	err := c.cc.Invoke(ctx, RuntimeService_TestRuntime_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) RemoveRuntime(ctx context.Context, in *RemoveRuntimeRequest, opts ...grpc.CallOption) (*RemoveRuntimeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RemoveRuntimeResponse)
	err := c.cc.Invoke(ctx, RuntimeService_RemoveRuntime_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) BuildRuntime(ctx context.Context, in *BuildRuntimeRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BuildRuntimeProgress], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &RuntimeService_ServiceDesc.Streams[0], RuntimeService_BuildRuntime_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BuildRuntimeRequest, BuildRuntimeProgress]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type RuntimeService_BuildRuntimeClient = grpc.ServerStreamingClient[BuildRuntimeProgress]

func (c *runtimeServiceClient) ValidateRuntimeYAML(ctx context.Context, in *ValidateRuntimeYAMLRequest, opts ...grpc.CallOption) (*ValidateRuntimeYAMLResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ValidateRuntimeYAMLResponse)
	err := c.cc.Invoke(ctx, RuntimeService_ValidateRuntimeYAML_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RuntimeServiceServer is the server API for RuntimeService service.
// All implementations must embed UnimplementedRuntimeServiceServer
// for forward compatibility.
//
// Runtime service for managing execution environments
type RuntimeServiceServer interface {
	ListRuntimes(context.Context, *EmptyRequest) (*ListRuntimesResponse, error)
	GetRuntimeInfo(context.Context, *GetRuntimeInfoRequest) (*GetRuntimeInfoResponse, error)
	TestRuntime(context.Context, *TestRuntimeRequest) (*TestRuntimeResponse, error)
	RemoveRuntime(context.Context, *RemoveRuntimeRequest) (*RemoveRuntimeResponse, error)
	// BuildRuntime builds a runtime from a YAML specification
	// The build process runs on the server and streams progress back to the client
	BuildRuntime(*BuildRuntimeRequest, grpc.ServerStreamingServer[BuildRuntimeProgress]) error
	// ValidateRuntimeYAML validates a runtime YAML specification without building
	ValidateRuntimeYAML(context.Context, *ValidateRuntimeYAMLRequest) (*ValidateRuntimeYAMLResponse, error)
	mustEmbedUnimplementedRuntimeServiceServer()
}

// UnimplementedRuntimeServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRuntimeServiceServer struct{}

func (UnimplementedRuntimeServiceServer) ListRuntimes(context.Context, *EmptyRequest) (*ListRuntimesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListRuntimes not implemented")
}
func (UnimplementedRuntimeServiceServer) GetRuntimeInfo(context.Context, *GetRuntimeInfoRequest) (*GetRuntimeInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRuntimeInfo not implemented")
}
func (UnimplementedRuntimeServiceServer) TestRuntime(context.Context, *TestRuntimeRequest) (*TestRuntimeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestRuntime not implemented")
}
func (UnimplementedRuntimeServiceServer) RemoveRuntime(context.Context, *RemoveRuntimeRequest) (*RemoveRuntimeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveRuntime not implemented")
}
func (UnimplementedRuntimeServiceServer) BuildRuntime(*BuildRuntimeRequest, grpc.ServerStreamingServer[BuildRuntimeProgress]) error {
	return status.Errorf(codes.Unimplemented, "method BuildRuntime not implemented")
}
func (UnimplementedRuntimeServiceServer) ValidateRuntimeYAML(context.Context, *ValidateRuntimeYAMLRequest) (*ValidateRuntimeYAMLResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateRuntimeYAML not implemented")
}
func (UnimplementedRuntimeServiceServer) mustEmbedUnimplementedRuntimeServiceServer() {}
func (UnimplementedRuntimeServiceServer) testEmbeddedByValue()                        {}

// UnsafeRuntimeServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RuntimeServiceServer will
// result in compilation errors.
type UnsafeRuntimeServiceServer interface {
	mustEmbedUnimplementedRuntimeServiceServer()
}

func RegisterRuntimeServiceServer(s grpc.ServiceRegistrar, srv RuntimeServiceServer) {
	// If the following call pancis, it indicates UnimplementedRuntimeServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&RuntimeService_ServiceDesc, srv)
}

func _RuntimeService_ListRuntimes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).ListRuntimes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_ListRuntimes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).ListRuntimes(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_GetRuntimeInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRuntimeInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).GetRuntimeInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_GetRuntimeInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).GetRuntimeInfo(ctx, req.(*GetRuntimeInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_TestRuntime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestRuntimeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).TestRuntime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_TestRuntime_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).TestRuntime(ctx, req.(*TestRuntimeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_RemoveRuntime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveRuntimeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).RemoveRuntime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_RemoveRuntime_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).RemoveRuntime(ctx, req.(*RemoveRuntimeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_BuildRuntime_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(BuildRuntimeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RuntimeServiceServer).BuildRuntime(m, &grpc.GenericServerStream[BuildRuntimeRequest, BuildRuntimeProgress]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type RuntimeService_BuildRuntimeServer = grpc.ServerStreamingServer[BuildRuntimeProgress]

func _RuntimeService_ValidateRuntimeYAML_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateRuntimeYAMLRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).ValidateRuntimeYAML(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_ValidateRuntimeYAML_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).ValidateRuntimeYAML(ctx, req.(*ValidateRuntimeYAMLRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RuntimeService_ServiceDesc is the grpc.ServiceDesc for RuntimeService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RuntimeService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "joblet.RuntimeService",
	HandlerType: (*RuntimeServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListRuntimes",
			Handler:    _RuntimeService_ListRuntimes_Handler,
		},
		{
			MethodName: "GetRuntimeInfo",
			Handler:    _RuntimeService_GetRuntimeInfo_Handler,
		},
		{
			MethodName: "TestRuntime",
			Handler:    _RuntimeService_TestRuntime_Handler,
		},
		{
			MethodName: "RemoveRuntime",
			Handler:    _RuntimeService_RemoveRuntime_Handler,
		},
		{
			MethodName: "ValidateRuntimeYAML",
			Handler:    _RuntimeService_ValidateRuntimeYAML_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "BuildRuntime",
			Handler:       _RuntimeService_BuildRuntime_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "joblet.proto",
}
