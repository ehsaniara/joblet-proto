// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.12.4
// source: joblet.proto

package gen

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	JobService_RunJob_FullMethodName            = "/joblet.JobService/RunJob"
	JobService_GetJobStatus_FullMethodName      = "/joblet.JobService/GetJobStatus"
	JobService_StopJob_FullMethodName           = "/joblet.JobService/StopJob"
	JobService_CancelJob_FullMethodName         = "/joblet.JobService/CancelJob"
	JobService_DeleteJob_FullMethodName         = "/joblet.JobService/DeleteJob"
	JobService_DeleteAllJobs_FullMethodName     = "/joblet.JobService/DeleteAllJobs"
	JobService_GetJobLogs_FullMethodName        = "/joblet.JobService/GetJobLogs"
	JobService_ListJobs_FullMethodName          = "/joblet.JobService/ListJobs"
	JobService_GetJobMetrics_FullMethodName     = "/joblet.JobService/GetJobMetrics"
	JobService_RunWorkflow_FullMethodName       = "/joblet.JobService/RunWorkflow"
	JobService_GetWorkflowStatus_FullMethodName = "/joblet.JobService/GetWorkflowStatus"
	JobService_ListWorkflows_FullMethodName     = "/joblet.JobService/ListWorkflows"
	JobService_GetWorkflowJobs_FullMethodName   = "/joblet.JobService/GetWorkflowJobs"
)

// JobServiceClient is the client API for JobService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Main service for running jobs and workflows
type JobServiceClient interface {
	// Job operations
	RunJob(ctx context.Context, in *RunJobRequest, opts ...grpc.CallOption) (*RunJobResponse, error)
	GetJobStatus(ctx context.Context, in *GetJobStatusReq, opts ...grpc.CallOption) (*GetJobStatusRes, error)
	StopJob(ctx context.Context, in *StopJobReq, opts ...grpc.CallOption) (*StopJobRes, error)
	CancelJob(ctx context.Context, in *CancelJobReq, opts ...grpc.CallOption) (*CancelJobRes, error)
	DeleteJob(ctx context.Context, in *DeleteJobReq, opts ...grpc.CallOption) (*DeleteJobRes, error)
	DeleteAllJobs(ctx context.Context, in *DeleteAllJobsReq, opts ...grpc.CallOption) (*DeleteAllJobsRes, error)
	GetJobLogs(ctx context.Context, in *GetJobLogsReq, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DataChunk], error)
	ListJobs(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*Jobs, error)
	// Job metrics operations
	GetJobMetrics(ctx context.Context, in *JobMetricsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[JobMetricsSample], error)
	// Workflow operations
	RunWorkflow(ctx context.Context, in *RunWorkflowRequest, opts ...grpc.CallOption) (*RunWorkflowResponse, error)
	GetWorkflowStatus(ctx context.Context, in *GetWorkflowStatusRequest, opts ...grpc.CallOption) (*GetWorkflowStatusResponse, error)
	ListWorkflows(ctx context.Context, in *ListWorkflowsRequest, opts ...grpc.CallOption) (*ListWorkflowsResponse, error)
	GetWorkflowJobs(ctx context.Context, in *GetWorkflowJobsRequest, opts ...grpc.CallOption) (*GetWorkflowJobsResponse, error)
}

type jobServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewJobServiceClient(cc grpc.ClientConnInterface) JobServiceClient {
	return &jobServiceClient{cc}
}

func (c *jobServiceClient) RunJob(ctx context.Context, in *RunJobRequest, opts ...grpc.CallOption) (*RunJobResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RunJobResponse)
	err := c.cc.Invoke(ctx, JobService_RunJob_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobServiceClient) GetJobStatus(ctx context.Context, in *GetJobStatusReq, opts ...grpc.CallOption) (*GetJobStatusRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetJobStatusRes)
	err := c.cc.Invoke(ctx, JobService_GetJobStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobServiceClient) StopJob(ctx context.Context, in *StopJobReq, opts ...grpc.CallOption) (*StopJobRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StopJobRes)
	err := c.cc.Invoke(ctx, JobService_StopJob_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobServiceClient) CancelJob(ctx context.Context, in *CancelJobReq, opts ...grpc.CallOption) (*CancelJobRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CancelJobRes)
	err := c.cc.Invoke(ctx, JobService_CancelJob_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobServiceClient) DeleteJob(ctx context.Context, in *DeleteJobReq, opts ...grpc.CallOption) (*DeleteJobRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteJobRes)
	err := c.cc.Invoke(ctx, JobService_DeleteJob_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobServiceClient) DeleteAllJobs(ctx context.Context, in *DeleteAllJobsReq, opts ...grpc.CallOption) (*DeleteAllJobsRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteAllJobsRes)
	err := c.cc.Invoke(ctx, JobService_DeleteAllJobs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobServiceClient) GetJobLogs(ctx context.Context, in *GetJobLogsReq, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DataChunk], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &JobService_ServiceDesc.Streams[0], JobService_GetJobLogs_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[GetJobLogsReq, DataChunk]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type JobService_GetJobLogsClient = grpc.ServerStreamingClient[DataChunk]

func (c *jobServiceClient) ListJobs(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*Jobs, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Jobs)
	err := c.cc.Invoke(ctx, JobService_ListJobs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobServiceClient) GetJobMetrics(ctx context.Context, in *JobMetricsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[JobMetricsSample], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &JobService_ServiceDesc.Streams[1], JobService_GetJobMetrics_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[JobMetricsRequest, JobMetricsSample]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type JobService_GetJobMetricsClient = grpc.ServerStreamingClient[JobMetricsSample]

func (c *jobServiceClient) RunWorkflow(ctx context.Context, in *RunWorkflowRequest, opts ...grpc.CallOption) (*RunWorkflowResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RunWorkflowResponse)
	err := c.cc.Invoke(ctx, JobService_RunWorkflow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobServiceClient) GetWorkflowStatus(ctx context.Context, in *GetWorkflowStatusRequest, opts ...grpc.CallOption) (*GetWorkflowStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetWorkflowStatusResponse)
	err := c.cc.Invoke(ctx, JobService_GetWorkflowStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobServiceClient) ListWorkflows(ctx context.Context, in *ListWorkflowsRequest, opts ...grpc.CallOption) (*ListWorkflowsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListWorkflowsResponse)
	err := c.cc.Invoke(ctx, JobService_ListWorkflows_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobServiceClient) GetWorkflowJobs(ctx context.Context, in *GetWorkflowJobsRequest, opts ...grpc.CallOption) (*GetWorkflowJobsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetWorkflowJobsResponse)
	err := c.cc.Invoke(ctx, JobService_GetWorkflowJobs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// JobServiceServer is the server API for JobService service.
// All implementations must embed UnimplementedJobServiceServer
// for forward compatibility.
//
// Main service for running jobs and workflows
type JobServiceServer interface {
	// Job operations
	RunJob(context.Context, *RunJobRequest) (*RunJobResponse, error)
	GetJobStatus(context.Context, *GetJobStatusReq) (*GetJobStatusRes, error)
	StopJob(context.Context, *StopJobReq) (*StopJobRes, error)
	CancelJob(context.Context, *CancelJobReq) (*CancelJobRes, error)
	DeleteJob(context.Context, *DeleteJobReq) (*DeleteJobRes, error)
	DeleteAllJobs(context.Context, *DeleteAllJobsReq) (*DeleteAllJobsRes, error)
	GetJobLogs(*GetJobLogsReq, grpc.ServerStreamingServer[DataChunk]) error
	ListJobs(context.Context, *EmptyRequest) (*Jobs, error)
	// Job metrics operations
	GetJobMetrics(*JobMetricsRequest, grpc.ServerStreamingServer[JobMetricsSample]) error
	// Workflow operations
	RunWorkflow(context.Context, *RunWorkflowRequest) (*RunWorkflowResponse, error)
	GetWorkflowStatus(context.Context, *GetWorkflowStatusRequest) (*GetWorkflowStatusResponse, error)
	ListWorkflows(context.Context, *ListWorkflowsRequest) (*ListWorkflowsResponse, error)
	GetWorkflowJobs(context.Context, *GetWorkflowJobsRequest) (*GetWorkflowJobsResponse, error)
	mustEmbedUnimplementedJobServiceServer()
}

// UnimplementedJobServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedJobServiceServer struct{}

func (UnimplementedJobServiceServer) RunJob(context.Context, *RunJobRequest) (*RunJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunJob not implemented")
}
func (UnimplementedJobServiceServer) GetJobStatus(context.Context, *GetJobStatusReq) (*GetJobStatusRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetJobStatus not implemented")
}
func (UnimplementedJobServiceServer) StopJob(context.Context, *StopJobReq) (*StopJobRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopJob not implemented")
}
func (UnimplementedJobServiceServer) CancelJob(context.Context, *CancelJobReq) (*CancelJobRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelJob not implemented")
}
func (UnimplementedJobServiceServer) DeleteJob(context.Context, *DeleteJobReq) (*DeleteJobRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteJob not implemented")
}
func (UnimplementedJobServiceServer) DeleteAllJobs(context.Context, *DeleteAllJobsReq) (*DeleteAllJobsRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAllJobs not implemented")
}
func (UnimplementedJobServiceServer) GetJobLogs(*GetJobLogsReq, grpc.ServerStreamingServer[DataChunk]) error {
	return status.Errorf(codes.Unimplemented, "method GetJobLogs not implemented")
}
func (UnimplementedJobServiceServer) ListJobs(context.Context, *EmptyRequest) (*Jobs, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListJobs not implemented")
}
func (UnimplementedJobServiceServer) GetJobMetrics(*JobMetricsRequest, grpc.ServerStreamingServer[JobMetricsSample]) error {
	return status.Errorf(codes.Unimplemented, "method GetJobMetrics not implemented")
}
func (UnimplementedJobServiceServer) RunWorkflow(context.Context, *RunWorkflowRequest) (*RunWorkflowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunWorkflow not implemented")
}
func (UnimplementedJobServiceServer) GetWorkflowStatus(context.Context, *GetWorkflowStatusRequest) (*GetWorkflowStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWorkflowStatus not implemented")
}
func (UnimplementedJobServiceServer) ListWorkflows(context.Context, *ListWorkflowsRequest) (*ListWorkflowsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListWorkflows not implemented")
}
func (UnimplementedJobServiceServer) GetWorkflowJobs(context.Context, *GetWorkflowJobsRequest) (*GetWorkflowJobsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWorkflowJobs not implemented")
}
func (UnimplementedJobServiceServer) mustEmbedUnimplementedJobServiceServer() {}
func (UnimplementedJobServiceServer) testEmbeddedByValue()                    {}

// UnsafeJobServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to JobServiceServer will
// result in compilation errors.
type UnsafeJobServiceServer interface {
	mustEmbedUnimplementedJobServiceServer()
}

func RegisterJobServiceServer(s grpc.ServiceRegistrar, srv JobServiceServer) {
	// If the following call pancis, it indicates UnimplementedJobServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&JobService_ServiceDesc, srv)
}

func _JobService_RunJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobServiceServer).RunJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobService_RunJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobServiceServer).RunJob(ctx, req.(*RunJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobService_GetJobStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetJobStatusReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobServiceServer).GetJobStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobService_GetJobStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobServiceServer).GetJobStatus(ctx, req.(*GetJobStatusReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobService_StopJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopJobReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobServiceServer).StopJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobService_StopJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobServiceServer).StopJob(ctx, req.(*StopJobReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobService_CancelJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelJobReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobServiceServer).CancelJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobService_CancelJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobServiceServer).CancelJob(ctx, req.(*CancelJobReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobService_DeleteJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteJobReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobServiceServer).DeleteJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobService_DeleteJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobServiceServer).DeleteJob(ctx, req.(*DeleteJobReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobService_DeleteAllJobs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAllJobsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobServiceServer).DeleteAllJobs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobService_DeleteAllJobs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobServiceServer).DeleteAllJobs(ctx, req.(*DeleteAllJobsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobService_GetJobLogs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetJobLogsReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(JobServiceServer).GetJobLogs(m, &grpc.GenericServerStream[GetJobLogsReq, DataChunk]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type JobService_GetJobLogsServer = grpc.ServerStreamingServer[DataChunk]

func _JobService_ListJobs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobServiceServer).ListJobs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobService_ListJobs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobServiceServer).ListJobs(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobService_GetJobMetrics_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(JobMetricsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(JobServiceServer).GetJobMetrics(m, &grpc.GenericServerStream[JobMetricsRequest, JobMetricsSample]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type JobService_GetJobMetricsServer = grpc.ServerStreamingServer[JobMetricsSample]

func _JobService_RunWorkflow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunWorkflowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobServiceServer).RunWorkflow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobService_RunWorkflow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobServiceServer).RunWorkflow(ctx, req.(*RunWorkflowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobService_GetWorkflowStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWorkflowStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobServiceServer).GetWorkflowStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobService_GetWorkflowStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobServiceServer).GetWorkflowStatus(ctx, req.(*GetWorkflowStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobService_ListWorkflows_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListWorkflowsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobServiceServer).ListWorkflows(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobService_ListWorkflows_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobServiceServer).ListWorkflows(ctx, req.(*ListWorkflowsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobService_GetWorkflowJobs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWorkflowJobsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobServiceServer).GetWorkflowJobs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JobService_GetWorkflowJobs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobServiceServer).GetWorkflowJobs(ctx, req.(*GetWorkflowJobsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// JobService_ServiceDesc is the grpc.ServiceDesc for JobService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var JobService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "joblet.JobService",
	HandlerType: (*JobServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RunJob",
			Handler:    _JobService_RunJob_Handler,
		},
		{
			MethodName: "GetJobStatus",
			Handler:    _JobService_GetJobStatus_Handler,
		},
		{
			MethodName: "StopJob",
			Handler:    _JobService_StopJob_Handler,
		},
		{
			MethodName: "CancelJob",
			Handler:    _JobService_CancelJob_Handler,
		},
		{
			MethodName: "DeleteJob",
			Handler:    _JobService_DeleteJob_Handler,
		},
		{
			MethodName: "DeleteAllJobs",
			Handler:    _JobService_DeleteAllJobs_Handler,
		},
		{
			MethodName: "ListJobs",
			Handler:    _JobService_ListJobs_Handler,
		},
		{
			MethodName: "RunWorkflow",
			Handler:    _JobService_RunWorkflow_Handler,
		},
		{
			MethodName: "GetWorkflowStatus",
			Handler:    _JobService_GetWorkflowStatus_Handler,
		},
		{
			MethodName: "ListWorkflows",
			Handler:    _JobService_ListWorkflows_Handler,
		},
		{
			MethodName: "GetWorkflowJobs",
			Handler:    _JobService_GetWorkflowJobs_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetJobLogs",
			Handler:       _JobService_GetJobLogs_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetJobMetrics",
			Handler:       _JobService_GetJobMetrics_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "joblet.proto",
}

const (
	NetworkService_CreateNetwork_FullMethodName = "/joblet.NetworkService/CreateNetwork"
	NetworkService_ListNetworks_FullMethodName  = "/joblet.NetworkService/ListNetworks"
	NetworkService_RemoveNetwork_FullMethodName = "/joblet.NetworkService/RemoveNetwork"
)

// NetworkServiceClient is the client API for NetworkService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Network service
type NetworkServiceClient interface {
	CreateNetwork(ctx context.Context, in *CreateNetworkReq, opts ...grpc.CallOption) (*CreateNetworkRes, error)
	ListNetworks(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*Networks, error)
	RemoveNetwork(ctx context.Context, in *RemoveNetworkReq, opts ...grpc.CallOption) (*RemoveNetworkRes, error)
}

type networkServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNetworkServiceClient(cc grpc.ClientConnInterface) NetworkServiceClient {
	return &networkServiceClient{cc}
}

func (c *networkServiceClient) CreateNetwork(ctx context.Context, in *CreateNetworkReq, opts ...grpc.CallOption) (*CreateNetworkRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateNetworkRes)
	err := c.cc.Invoke(ctx, NetworkService_CreateNetwork_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkServiceClient) ListNetworks(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*Networks, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Networks)
	err := c.cc.Invoke(ctx, NetworkService_ListNetworks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkServiceClient) RemoveNetwork(ctx context.Context, in *RemoveNetworkReq, opts ...grpc.CallOption) (*RemoveNetworkRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RemoveNetworkRes)
	err := c.cc.Invoke(ctx, NetworkService_RemoveNetwork_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NetworkServiceServer is the server API for NetworkService service.
// All implementations must embed UnimplementedNetworkServiceServer
// for forward compatibility.
//
// Network service
type NetworkServiceServer interface {
	CreateNetwork(context.Context, *CreateNetworkReq) (*CreateNetworkRes, error)
	ListNetworks(context.Context, *EmptyRequest) (*Networks, error)
	RemoveNetwork(context.Context, *RemoveNetworkReq) (*RemoveNetworkRes, error)
	mustEmbedUnimplementedNetworkServiceServer()
}

// UnimplementedNetworkServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedNetworkServiceServer struct{}

func (UnimplementedNetworkServiceServer) CreateNetwork(context.Context, *CreateNetworkReq) (*CreateNetworkRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateNetwork not implemented")
}
func (UnimplementedNetworkServiceServer) ListNetworks(context.Context, *EmptyRequest) (*Networks, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNetworks not implemented")
}
func (UnimplementedNetworkServiceServer) RemoveNetwork(context.Context, *RemoveNetworkReq) (*RemoveNetworkRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveNetwork not implemented")
}
func (UnimplementedNetworkServiceServer) mustEmbedUnimplementedNetworkServiceServer() {}
func (UnimplementedNetworkServiceServer) testEmbeddedByValue()                        {}

// UnsafeNetworkServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NetworkServiceServer will
// result in compilation errors.
type UnsafeNetworkServiceServer interface {
	mustEmbedUnimplementedNetworkServiceServer()
}

func RegisterNetworkServiceServer(s grpc.ServiceRegistrar, srv NetworkServiceServer) {
	// If the following call pancis, it indicates UnimplementedNetworkServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&NetworkService_ServiceDesc, srv)
}

func _NetworkService_CreateNetwork_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateNetworkReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkServiceServer).CreateNetwork(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkService_CreateNetwork_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkServiceServer).CreateNetwork(ctx, req.(*CreateNetworkReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkService_ListNetworks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkServiceServer).ListNetworks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkService_ListNetworks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkServiceServer).ListNetworks(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkService_RemoveNetwork_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveNetworkReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkServiceServer).RemoveNetwork(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkService_RemoveNetwork_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkServiceServer).RemoveNetwork(ctx, req.(*RemoveNetworkReq))
	}
	return interceptor(ctx, in, info, handler)
}

// NetworkService_ServiceDesc is the grpc.ServiceDesc for NetworkService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NetworkService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "joblet.NetworkService",
	HandlerType: (*NetworkServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateNetwork",
			Handler:    _NetworkService_CreateNetwork_Handler,
		},
		{
			MethodName: "ListNetworks",
			Handler:    _NetworkService_ListNetworks_Handler,
		},
		{
			MethodName: "RemoveNetwork",
			Handler:    _NetworkService_RemoveNetwork_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "joblet.proto",
}

const (
	VolumeService_CreateVolume_FullMethodName = "/joblet.VolumeService/CreateVolume"
	VolumeService_ListVolumes_FullMethodName  = "/joblet.VolumeService/ListVolumes"
	VolumeService_RemoveVolume_FullMethodName = "/joblet.VolumeService/RemoveVolume"
)

// VolumeServiceClient is the client API for VolumeService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Volume service
type VolumeServiceClient interface {
	CreateVolume(ctx context.Context, in *CreateVolumeReq, opts ...grpc.CallOption) (*CreateVolumeRes, error)
	ListVolumes(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*Volumes, error)
	RemoveVolume(ctx context.Context, in *RemoveVolumeReq, opts ...grpc.CallOption) (*RemoveVolumeRes, error)
}

type volumeServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewVolumeServiceClient(cc grpc.ClientConnInterface) VolumeServiceClient {
	return &volumeServiceClient{cc}
}

func (c *volumeServiceClient) CreateVolume(ctx context.Context, in *CreateVolumeReq, opts ...grpc.CallOption) (*CreateVolumeRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateVolumeRes)
	err := c.cc.Invoke(ctx, VolumeService_CreateVolume_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumeServiceClient) ListVolumes(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*Volumes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Volumes)
	err := c.cc.Invoke(ctx, VolumeService_ListVolumes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *volumeServiceClient) RemoveVolume(ctx context.Context, in *RemoveVolumeReq, opts ...grpc.CallOption) (*RemoveVolumeRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RemoveVolumeRes)
	err := c.cc.Invoke(ctx, VolumeService_RemoveVolume_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VolumeServiceServer is the server API for VolumeService service.
// All implementations must embed UnimplementedVolumeServiceServer
// for forward compatibility.
//
// Volume service
type VolumeServiceServer interface {
	CreateVolume(context.Context, *CreateVolumeReq) (*CreateVolumeRes, error)
	ListVolumes(context.Context, *EmptyRequest) (*Volumes, error)
	RemoveVolume(context.Context, *RemoveVolumeReq) (*RemoveVolumeRes, error)
	mustEmbedUnimplementedVolumeServiceServer()
}

// UnimplementedVolumeServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedVolumeServiceServer struct{}

func (UnimplementedVolumeServiceServer) CreateVolume(context.Context, *CreateVolumeReq) (*CreateVolumeRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateVolume not implemented")
}
func (UnimplementedVolumeServiceServer) ListVolumes(context.Context, *EmptyRequest) (*Volumes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListVolumes not implemented")
}
func (UnimplementedVolumeServiceServer) RemoveVolume(context.Context, *RemoveVolumeReq) (*RemoveVolumeRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveVolume not implemented")
}
func (UnimplementedVolumeServiceServer) mustEmbedUnimplementedVolumeServiceServer() {}
func (UnimplementedVolumeServiceServer) testEmbeddedByValue()                       {}

// UnsafeVolumeServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VolumeServiceServer will
// result in compilation errors.
type UnsafeVolumeServiceServer interface {
	mustEmbedUnimplementedVolumeServiceServer()
}

func RegisterVolumeServiceServer(s grpc.ServiceRegistrar, srv VolumeServiceServer) {
	// If the following call pancis, it indicates UnimplementedVolumeServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&VolumeService_ServiceDesc, srv)
}

func _VolumeService_CreateVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateVolumeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServiceServer).CreateVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VolumeService_CreateVolume_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServiceServer).CreateVolume(ctx, req.(*CreateVolumeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _VolumeService_ListVolumes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServiceServer).ListVolumes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VolumeService_ListVolumes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServiceServer).ListVolumes(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VolumeService_RemoveVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveVolumeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VolumeServiceServer).RemoveVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VolumeService_RemoveVolume_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VolumeServiceServer).RemoveVolume(ctx, req.(*RemoveVolumeReq))
	}
	return interceptor(ctx, in, info, handler)
}

// VolumeService_ServiceDesc is the grpc.ServiceDesc for VolumeService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VolumeService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "joblet.VolumeService",
	HandlerType: (*VolumeServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateVolume",
			Handler:    _VolumeService_CreateVolume_Handler,
		},
		{
			MethodName: "ListVolumes",
			Handler:    _VolumeService_ListVolumes_Handler,
		},
		{
			MethodName: "RemoveVolume",
			Handler:    _VolumeService_RemoveVolume_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "joblet.proto",
}

const (
	MonitoringService_GetSystemStatus_FullMethodName     = "/joblet.MonitoringService/GetSystemStatus"
	MonitoringService_StreamSystemMetrics_FullMethodName = "/joblet.MonitoringService/StreamSystemMetrics"
)

// MonitoringServiceClient is the client API for MonitoringService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Monitoring service
type MonitoringServiceClient interface {
	GetSystemStatus(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*SystemStatusRes, error)
	StreamSystemMetrics(ctx context.Context, in *StreamMetricsReq, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SystemMetricsRes], error)
}

type monitoringServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMonitoringServiceClient(cc grpc.ClientConnInterface) MonitoringServiceClient {
	return &monitoringServiceClient{cc}
}

func (c *monitoringServiceClient) GetSystemStatus(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*SystemStatusRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SystemStatusRes)
	err := c.cc.Invoke(ctx, MonitoringService_GetSystemStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monitoringServiceClient) StreamSystemMetrics(ctx context.Context, in *StreamMetricsReq, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SystemMetricsRes], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &MonitoringService_ServiceDesc.Streams[0], MonitoringService_StreamSystemMetrics_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamMetricsReq, SystemMetricsRes]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MonitoringService_StreamSystemMetricsClient = grpc.ServerStreamingClient[SystemMetricsRes]

// MonitoringServiceServer is the server API for MonitoringService service.
// All implementations must embed UnimplementedMonitoringServiceServer
// for forward compatibility.
//
// Monitoring service
type MonitoringServiceServer interface {
	GetSystemStatus(context.Context, *EmptyRequest) (*SystemStatusRes, error)
	StreamSystemMetrics(*StreamMetricsReq, grpc.ServerStreamingServer[SystemMetricsRes]) error
	mustEmbedUnimplementedMonitoringServiceServer()
}

// UnimplementedMonitoringServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMonitoringServiceServer struct{}

func (UnimplementedMonitoringServiceServer) GetSystemStatus(context.Context, *EmptyRequest) (*SystemStatusRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSystemStatus not implemented")
}
func (UnimplementedMonitoringServiceServer) StreamSystemMetrics(*StreamMetricsReq, grpc.ServerStreamingServer[SystemMetricsRes]) error {
	return status.Errorf(codes.Unimplemented, "method StreamSystemMetrics not implemented")
}
func (UnimplementedMonitoringServiceServer) mustEmbedUnimplementedMonitoringServiceServer() {}
func (UnimplementedMonitoringServiceServer) testEmbeddedByValue()                           {}

// UnsafeMonitoringServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MonitoringServiceServer will
// result in compilation errors.
type UnsafeMonitoringServiceServer interface {
	mustEmbedUnimplementedMonitoringServiceServer()
}

func RegisterMonitoringServiceServer(s grpc.ServiceRegistrar, srv MonitoringServiceServer) {
	// If the following call pancis, it indicates UnimplementedMonitoringServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MonitoringService_ServiceDesc, srv)
}

func _MonitoringService_GetSystemStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonitoringServiceServer).GetSystemStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MonitoringService_GetSystemStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonitoringServiceServer).GetSystemStatus(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MonitoringService_StreamSystemMetrics_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamMetricsReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MonitoringServiceServer).StreamSystemMetrics(m, &grpc.GenericServerStream[StreamMetricsReq, SystemMetricsRes]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MonitoringService_StreamSystemMetricsServer = grpc.ServerStreamingServer[SystemMetricsRes]

// MonitoringService_ServiceDesc is the grpc.ServiceDesc for MonitoringService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MonitoringService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "joblet.MonitoringService",
	HandlerType: (*MonitoringServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetSystemStatus",
			Handler:    _MonitoringService_GetSystemStatus_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamSystemMetrics",
			Handler:       _MonitoringService_StreamSystemMetrics_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "joblet.proto",
}

const (
	RuntimeService_ListRuntimes_FullMethodName                      = "/joblet.RuntimeService/ListRuntimes"
	RuntimeService_GetRuntimeInfo_FullMethodName                    = "/joblet.RuntimeService/GetRuntimeInfo"
	RuntimeService_TestRuntime_FullMethodName                       = "/joblet.RuntimeService/TestRuntime"
	RuntimeService_InstallRuntimeFromGithub_FullMethodName          = "/joblet.RuntimeService/InstallRuntimeFromGithub"
	RuntimeService_InstallRuntimeFromLocal_FullMethodName           = "/joblet.RuntimeService/InstallRuntimeFromLocal"
	RuntimeService_StreamingInstallRuntimeFromGithub_FullMethodName = "/joblet.RuntimeService/StreamingInstallRuntimeFromGithub"
	RuntimeService_StreamingInstallRuntimeFromLocal_FullMethodName  = "/joblet.RuntimeService/StreamingInstallRuntimeFromLocal"
	RuntimeService_ValidateRuntimeSpec_FullMethodName               = "/joblet.RuntimeService/ValidateRuntimeSpec"
	RuntimeService_RemoveRuntime_FullMethodName                     = "/joblet.RuntimeService/RemoveRuntime"
)

// RuntimeServiceClient is the client API for RuntimeService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Runtime service for managing execution environments
type RuntimeServiceClient interface {
	ListRuntimes(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*RuntimesRes, error)
	GetRuntimeInfo(ctx context.Context, in *RuntimeInfoReq, opts ...grpc.CallOption) (*RuntimeInfoRes, error)
	TestRuntime(ctx context.Context, in *RuntimeTestReq, opts ...grpc.CallOption) (*RuntimeTestRes, error)
	InstallRuntimeFromGithub(ctx context.Context, in *InstallRuntimeRequest, opts ...grpc.CallOption) (*InstallRuntimeResponse, error)
	InstallRuntimeFromLocal(ctx context.Context, in *InstallRuntimeFromLocalRequest, opts ...grpc.CallOption) (*InstallRuntimeResponse, error)
	StreamingInstallRuntimeFromGithub(ctx context.Context, in *InstallRuntimeRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[RuntimeInstallationChunk], error)
	StreamingInstallRuntimeFromLocal(ctx context.Context, in *InstallRuntimeFromLocalRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[RuntimeInstallationChunk], error)
	ValidateRuntimeSpec(ctx context.Context, in *ValidateRuntimeSpecRequest, opts ...grpc.CallOption) (*ValidateRuntimeSpecResponse, error)
	RemoveRuntime(ctx context.Context, in *RuntimeRemoveReq, opts ...grpc.CallOption) (*RuntimeRemoveRes, error)
}

type runtimeServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewRuntimeServiceClient(cc grpc.ClientConnInterface) RuntimeServiceClient {
	return &runtimeServiceClient{cc}
}

func (c *runtimeServiceClient) ListRuntimes(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*RuntimesRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RuntimesRes)
	err := c.cc.Invoke(ctx, RuntimeService_ListRuntimes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) GetRuntimeInfo(ctx context.Context, in *RuntimeInfoReq, opts ...grpc.CallOption) (*RuntimeInfoRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RuntimeInfoRes)
	err := c.cc.Invoke(ctx, RuntimeService_GetRuntimeInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) TestRuntime(ctx context.Context, in *RuntimeTestReq, opts ...grpc.CallOption) (*RuntimeTestRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RuntimeTestRes)
	err := c.cc.Invoke(ctx, RuntimeService_TestRuntime_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) InstallRuntimeFromGithub(ctx context.Context, in *InstallRuntimeRequest, opts ...grpc.CallOption) (*InstallRuntimeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InstallRuntimeResponse)
	err := c.cc.Invoke(ctx, RuntimeService_InstallRuntimeFromGithub_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) InstallRuntimeFromLocal(ctx context.Context, in *InstallRuntimeFromLocalRequest, opts ...grpc.CallOption) (*InstallRuntimeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InstallRuntimeResponse)
	err := c.cc.Invoke(ctx, RuntimeService_InstallRuntimeFromLocal_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) StreamingInstallRuntimeFromGithub(ctx context.Context, in *InstallRuntimeRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[RuntimeInstallationChunk], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &RuntimeService_ServiceDesc.Streams[0], RuntimeService_StreamingInstallRuntimeFromGithub_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[InstallRuntimeRequest, RuntimeInstallationChunk]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type RuntimeService_StreamingInstallRuntimeFromGithubClient = grpc.ServerStreamingClient[RuntimeInstallationChunk]

func (c *runtimeServiceClient) StreamingInstallRuntimeFromLocal(ctx context.Context, in *InstallRuntimeFromLocalRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[RuntimeInstallationChunk], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &RuntimeService_ServiceDesc.Streams[1], RuntimeService_StreamingInstallRuntimeFromLocal_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[InstallRuntimeFromLocalRequest, RuntimeInstallationChunk]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type RuntimeService_StreamingInstallRuntimeFromLocalClient = grpc.ServerStreamingClient[RuntimeInstallationChunk]

func (c *runtimeServiceClient) ValidateRuntimeSpec(ctx context.Context, in *ValidateRuntimeSpecRequest, opts ...grpc.CallOption) (*ValidateRuntimeSpecResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ValidateRuntimeSpecResponse)
	err := c.cc.Invoke(ctx, RuntimeService_ValidateRuntimeSpec_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) RemoveRuntime(ctx context.Context, in *RuntimeRemoveReq, opts ...grpc.CallOption) (*RuntimeRemoveRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RuntimeRemoveRes)
	err := c.cc.Invoke(ctx, RuntimeService_RemoveRuntime_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RuntimeServiceServer is the server API for RuntimeService service.
// All implementations must embed UnimplementedRuntimeServiceServer
// for forward compatibility.
//
// Runtime service for managing execution environments
type RuntimeServiceServer interface {
	ListRuntimes(context.Context, *EmptyRequest) (*RuntimesRes, error)
	GetRuntimeInfo(context.Context, *RuntimeInfoReq) (*RuntimeInfoRes, error)
	TestRuntime(context.Context, *RuntimeTestReq) (*RuntimeTestRes, error)
	InstallRuntimeFromGithub(context.Context, *InstallRuntimeRequest) (*InstallRuntimeResponse, error)
	InstallRuntimeFromLocal(context.Context, *InstallRuntimeFromLocalRequest) (*InstallRuntimeResponse, error)
	StreamingInstallRuntimeFromGithub(*InstallRuntimeRequest, grpc.ServerStreamingServer[RuntimeInstallationChunk]) error
	StreamingInstallRuntimeFromLocal(*InstallRuntimeFromLocalRequest, grpc.ServerStreamingServer[RuntimeInstallationChunk]) error
	ValidateRuntimeSpec(context.Context, *ValidateRuntimeSpecRequest) (*ValidateRuntimeSpecResponse, error)
	RemoveRuntime(context.Context, *RuntimeRemoveReq) (*RuntimeRemoveRes, error)
	mustEmbedUnimplementedRuntimeServiceServer()
}

// UnimplementedRuntimeServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRuntimeServiceServer struct{}

func (UnimplementedRuntimeServiceServer) ListRuntimes(context.Context, *EmptyRequest) (*RuntimesRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListRuntimes not implemented")
}
func (UnimplementedRuntimeServiceServer) GetRuntimeInfo(context.Context, *RuntimeInfoReq) (*RuntimeInfoRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRuntimeInfo not implemented")
}
func (UnimplementedRuntimeServiceServer) TestRuntime(context.Context, *RuntimeTestReq) (*RuntimeTestRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestRuntime not implemented")
}
func (UnimplementedRuntimeServiceServer) InstallRuntimeFromGithub(context.Context, *InstallRuntimeRequest) (*InstallRuntimeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InstallRuntimeFromGithub not implemented")
}
func (UnimplementedRuntimeServiceServer) InstallRuntimeFromLocal(context.Context, *InstallRuntimeFromLocalRequest) (*InstallRuntimeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InstallRuntimeFromLocal not implemented")
}
func (UnimplementedRuntimeServiceServer) StreamingInstallRuntimeFromGithub(*InstallRuntimeRequest, grpc.ServerStreamingServer[RuntimeInstallationChunk]) error {
	return status.Errorf(codes.Unimplemented, "method StreamingInstallRuntimeFromGithub not implemented")
}
func (UnimplementedRuntimeServiceServer) StreamingInstallRuntimeFromLocal(*InstallRuntimeFromLocalRequest, grpc.ServerStreamingServer[RuntimeInstallationChunk]) error {
	return status.Errorf(codes.Unimplemented, "method StreamingInstallRuntimeFromLocal not implemented")
}
func (UnimplementedRuntimeServiceServer) ValidateRuntimeSpec(context.Context, *ValidateRuntimeSpecRequest) (*ValidateRuntimeSpecResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateRuntimeSpec not implemented")
}
func (UnimplementedRuntimeServiceServer) RemoveRuntime(context.Context, *RuntimeRemoveReq) (*RuntimeRemoveRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveRuntime not implemented")
}
func (UnimplementedRuntimeServiceServer) mustEmbedUnimplementedRuntimeServiceServer() {}
func (UnimplementedRuntimeServiceServer) testEmbeddedByValue()                        {}

// UnsafeRuntimeServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RuntimeServiceServer will
// result in compilation errors.
type UnsafeRuntimeServiceServer interface {
	mustEmbedUnimplementedRuntimeServiceServer()
}

func RegisterRuntimeServiceServer(s grpc.ServiceRegistrar, srv RuntimeServiceServer) {
	// If the following call pancis, it indicates UnimplementedRuntimeServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&RuntimeService_ServiceDesc, srv)
}

func _RuntimeService_ListRuntimes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).ListRuntimes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_ListRuntimes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).ListRuntimes(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_GetRuntimeInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RuntimeInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).GetRuntimeInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_GetRuntimeInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).GetRuntimeInfo(ctx, req.(*RuntimeInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_TestRuntime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RuntimeTestReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).TestRuntime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_TestRuntime_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).TestRuntime(ctx, req.(*RuntimeTestReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_InstallRuntimeFromGithub_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstallRuntimeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).InstallRuntimeFromGithub(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_InstallRuntimeFromGithub_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).InstallRuntimeFromGithub(ctx, req.(*InstallRuntimeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_InstallRuntimeFromLocal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstallRuntimeFromLocalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).InstallRuntimeFromLocal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_InstallRuntimeFromLocal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).InstallRuntimeFromLocal(ctx, req.(*InstallRuntimeFromLocalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_StreamingInstallRuntimeFromGithub_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(InstallRuntimeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RuntimeServiceServer).StreamingInstallRuntimeFromGithub(m, &grpc.GenericServerStream[InstallRuntimeRequest, RuntimeInstallationChunk]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type RuntimeService_StreamingInstallRuntimeFromGithubServer = grpc.ServerStreamingServer[RuntimeInstallationChunk]

func _RuntimeService_StreamingInstallRuntimeFromLocal_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(InstallRuntimeFromLocalRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RuntimeServiceServer).StreamingInstallRuntimeFromLocal(m, &grpc.GenericServerStream[InstallRuntimeFromLocalRequest, RuntimeInstallationChunk]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type RuntimeService_StreamingInstallRuntimeFromLocalServer = grpc.ServerStreamingServer[RuntimeInstallationChunk]

func _RuntimeService_ValidateRuntimeSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateRuntimeSpecRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).ValidateRuntimeSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_ValidateRuntimeSpec_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).ValidateRuntimeSpec(ctx, req.(*ValidateRuntimeSpecRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_RemoveRuntime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RuntimeRemoveReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).RemoveRuntime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_RemoveRuntime_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).RemoveRuntime(ctx, req.(*RuntimeRemoveReq))
	}
	return interceptor(ctx, in, info, handler)
}

// RuntimeService_ServiceDesc is the grpc.ServiceDesc for RuntimeService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RuntimeService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "joblet.RuntimeService",
	HandlerType: (*RuntimeServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListRuntimes",
			Handler:    _RuntimeService_ListRuntimes_Handler,
		},
		{
			MethodName: "GetRuntimeInfo",
			Handler:    _RuntimeService_GetRuntimeInfo_Handler,
		},
		{
			MethodName: "TestRuntime",
			Handler:    _RuntimeService_TestRuntime_Handler,
		},
		{
			MethodName: "InstallRuntimeFromGithub",
			Handler:    _RuntimeService_InstallRuntimeFromGithub_Handler,
		},
		{
			MethodName: "InstallRuntimeFromLocal",
			Handler:    _RuntimeService_InstallRuntimeFromLocal_Handler,
		},
		{
			MethodName: "ValidateRuntimeSpec",
			Handler:    _RuntimeService_ValidateRuntimeSpec_Handler,
		},
		{
			MethodName: "RemoveRuntime",
			Handler:    _RuntimeService_RemoveRuntime_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamingInstallRuntimeFromGithub",
			Handler:       _RuntimeService_StreamingInstallRuntimeFromGithub_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamingInstallRuntimeFromLocal",
			Handler:       _RuntimeService_StreamingInstallRuntimeFromLocal_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "joblet.proto",
}
